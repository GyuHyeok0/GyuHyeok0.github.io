---
layout: single
title: "Java 객체"
categories:
  - 자바 이론
toc: true
author_profiles: false
sidebar:
  nav: "docs"
tags:
  - Java
---

# 클래스

- 클래스는 서로 다른형의 자료형의 데이터를 사용자(개발자) 정의로 하나로 묶어 새로운 타입을 정의(배열과 달리 다른 자료형들의 값을 하나로 묶을 수 있음
- 다른 곳에서 클래스의 필드에 접근하기 위해 참조연산자를 활용
    
    ```jsx
    public class Applicaiton01 {
    
    Monster monster1 = new Monster(); //참조연산자
            monster1.setName("드라큘라");
    System.out.println("monster1 name = " + monster1.name);
    
    }
    ```
    
    ```jsx
    public class Monster {
    
    String kinds;
    
    public void setName(String name) {
    
            this.kinds = name;
    				System out plint
    
        }
    }
    ```
    

# 캡슐화

- 캡슐화는 결합도를 낮추기 위해 필드의 직접 접근을 제한하고 public 메소드를 이용해서 간접적으로 접근하여 사용할 수 있도록 만든 기술
- 필드 접근제한자
    - public - 모든 패키지에 접근 허용
    - protected - 동일 패키지에 접근 허용 ( 상속 관계)
    - default - 동일 패키지에 접근 허용
    - private - 해당 클래스 내부에만 접근 허용
- 사용방법
    
    ```jsx
       	private String name1;
    
        public void setname (String 매개변수){
    
            this.name1 = 매개변수;
            System.out.println(this.name1);
        }
    ```
    

# 객채지향언어

- **클래스(class)란?**
객체를 추상화한 것으로 인스턴스를 생성 할 목적으로 정의 해놓은 소스 코드 작성 단위
(자바에서 객체를 구현하기 위한 매커니즘으로 클래스를 사용한다)
ex) 회원, 자동차, 도서 등
- **객체(Object)란?**
현실에 존재하는 독립적이면서 하나로 취급되는 사물이나 개념
클래스에 정의된 대로 new 연산자를 통해 heap에 할당된 공간 (== 인스턴스)
    
    *`하나의 객체는 너무 많을 수행하는 것이 아닌 적절한 책임을 가지고 있어야한다.(단일책임의 원칙`*
    
- **추상화(abstraction)란?**
유연성을 확보하기 위해 구체적인 것은 제거한다는 의미
프로그램에서 필요한 공통점을 추출하고, 불필요한 공통점을 제거하는 과정
    
    *`유지보수성 증가`*
    
- **생성자(Constructor)란?**
객체가 new 연산자를 통해 Heap 메모리 영역에 할당될 때 1회성으로 호출되는 리턴타입이 없는 메소드
인스턴스 생성 시 필드 초기화 목적으로 주로 사용 된다.
    
    `생성자 작성 규칙생성자의 선언은 메소드 선언과 유사하지만 반환값이 없음생성자명을 클래스명과 동일해야 함`
    

# Setter 와 Getter

캡슐화의 원칙에는 일부 어긋나긴 하지만 다른 목적을 가진 클래스와 객체를 추상화하는 기법이있다.행위 위주가 아닌 데이터를 하나로 뭉치기 위한 객체이러한 객체를 설계할때는 행위가 아닌 데이터 위주이며, 캡슐화의 원칙을 준수하여 모든 필드를 private로 직접 접근을 막고, 필드 값을 변경하거나, 반환하는 메소드를 세트로 미리 준비해둔다.너가 어떤것을 쓸 줄 모르니 다 준비해봤어 라는 종합선물세트이다private 필드와 필드값을 수정하는 설정자 setter, 필드에 접근하는 접근자 getter 들로 구성주로 계층간 데이터를 주고 받을 목적으로 사용한다.

- **설정자 작성규칙**
    
    필드값을 변경할 목적의 매개변수를 변경하려는 필드와 같은 자료형으로 선언하고 호출 당시 전달 되는 매개변수의 값을 이용하여 필드 값을 변경한다.
    
    ```jsx
    public void set필드명(매개변수) {
                    필드 = 매개변수;
                }
    ```
    
- **접근자 작성규칙**
    
    필드의 값을 반환받는 목적의 메소드 집합을 의미한다. 각 접근자는 하나의 필드에만 접근하도록 한다. 필드에 접근해서 기록된 값을 return 으로 반환하며, 이때 반환 타입은 자료형과 일치한다.
    
    ```jsx
    public 반환형 get필드명() {
            return 반환값;
            }
    ```
    

# 생성자

- **생성자(Constructor)란?**
객체가 new 연산자를 통해 Heap 메모리 영역에 할당될 때 1회성으로 호출되는 리턴타입이 없는 메소드
인스턴스 생성 시 필드 초기화 목적으로 주로 사용 된다.
- **생성자 작성 규칙**
생성자의 선언은 메소드 선언과 유사하지만 반환값이 없음
생성자명을 클래스명과 동일해야 함
    
    `인스턴스를 생성할 때 초기 수행할 명령이 있는 경우 미리 작성해두고, 인스턴스를 생성할 떄 (*new* 키워드를 만날 때) 호출된다. 생성자 함수에 매개변수가 없는 생성자를 기본 생성자 기본생성자는 compiler 에 자동으로 추가되기 때문에 지금까지 명시적으로 사용할 수 있었다.`
    
- 기본생성자
    
    기본 생성자가 명시적으로 작성되지 않은 경우, 자바 컴파일러가 자동으로 기본 생성자를 생성하는데, 이 때 생성자 중 하나라도 매개변수를 갖고 있다면, 해당 클래스에 기본 생성자를 자동으로 생성하지 않습니다.
    
    *`매개변수가 있는 생성자가 존재하는 경우 기본생성자를 명시적으로 작성해줘야 한다.`*
    
- 매개변수가 있는 생성자
    
    *`매개변수 있는 생성자의 주 목적은 인스턴스 생성 시점에 매개변수로 전달. 받은 값을 이용해서 필드를 초기화 하는 목적이다.`*
    
- 사전에 작성 되어 있는 생성자
    
    *`this*(id, pwd, name);`
    

# 오버로딩

- **오버로딩(Overloading)이란?**
동일한 메소드명으로 다양한 종류의 매개변수에 따라 다르게 처리해야하는 것을 관리하기
위해 사용하는 기술
- 동일한 메소드명의 매개변수의 타입, 개수, 순서를 다르게 작성
(메소드의 시그니처(Signature)가 다르지만 메소드 명은 같게 함)

# 가변인자

- 함수나 메서드가 임의의 개수의 인자를 받을 수 있도록 설계된 매개변수입니다. 일반적으로 함수 정의 시에 명시된 매개변수의 개수가 고정되어 있는데, 가변인자를 사용하면 함수가 실행될 때 전달되는 인자의 개수에 유연하게 대응할 수 있습니다.
    
    *`인자로 전달하는 값의 갯수가 정해지지 않은 경우 가변배열을 이용할 수 있다.`*
    
    ```jsx
    public void testVariableLengthArrayParameter (String name, String...hobby) {
    
            System.out.println("이름 : " + name);
            System.out.print("취미 : ");
            
            for (int i =0 ;i <hobby.length; i++) {
                System.out.print(hobby[i]  + "  ");
            }
        }
    ```
    

# 파라미터

- 메소드의 파라미터 선언부에는 다양한 종류의 값을 인자로 전달하여 호출 가능

# Static

- static이란?
정적 메모리 영역에 프로그램이 start될 시 할당 하고자 할 때 사용하는 키워드
static 필드나 메소드는 인스턴스 생성 없이 사용 가능하다.
- 여러 인스턴스가 공유해서 사용할 목적으로 만드는 것

- 전역변수의 값이 static 일때

*`static 필드에 접근하기 위해서는 클래스명.필드명 으로 접근한다.this. 으로 접근이 가능하지만, this 를 사용하지 않는 것이 좋다.`*

- Method 가 스테틱일때

*`this.count;  //스테틱 메서드는 주소가 없기 때문에 오류가 뜬다.`*

- 인스턴스 변수와 static 변수의 차이: 초기화와 메모리 공유

`StaticFieldTest sft1 = *new* StaticFieldTest();`

`StaticFieldTest sft2 = *new* StaticFieldTest();`

인스턴스 변수는 클래스의 각 인스턴스마다 별개의 메모리를 가지며 기본값으로 초기화되지만, static 변수는 클래스 레벨에서 하나의 공유된 메모리를 사용하며 초기화되어 유지됩니다.

# 초기화 블럭

- 복잡한 초기화를 수행 할 수 있는 블럭을 제공하며, 인스턴스 초기화 블럭과 정적 초기화 블럭으로 구분된다.
- 인스턴스 초기화 블럭
    
    ```jsx
    
    {
            초기화 내용
                }
    ```
    

- 정적 초기화 블럭
    
    ```jsx
      static{
             초기화 내용 작성
                }
    ```
    
    *`static 초기화 블럭에서는 non- static 필드를 초기화 하지 못한다. 동작시점에서 인스턴스는 존재 할 수 없기 때문.`*
    
- 초기화순서
    
    *`인스터스 변수 : 기본값 -> 명시적 초기값 -> 인스턴스 초기화 블럭 -> 생성자`*
    
    *`클래스 변수 : 기본값 -> 명시적 초기값 -> 정적초기화 -> 인스턴스 초기화 블럭 -> 생성자`*
    

# 객체배열

- **객체배열이란?**
    
    객체배열은 레퍼런스 변수에 대한 배열이다. * 생성한 인스턴스도 배열을 이용해서 관리하면 * 동일한 타입의 여러 개 인스턴스를 각각 취급하지 않고 연속 처리할 수 있어서 유용하다. * 또한 반환값은(return) 1개의 값만 반환할 수 있기 때문에 * 동일한 타입의 여러 인스턴스를 반환해야 하는 경우 객체 배열을 이용할 수 있다.
    
    ```jsx
    Car[] carArray = new Car[5];
    
            carArray[0] = new Car("페라리", 300);
            carArray[1] = new Car("람보르기니", 350);
            carArray[2] = new Car("롤스로이스", 250);
            carArray[3] = new Car("부가티", 400);
            carArray[4] = new Car("모닝", 500);
    //        carArray[5] = new Car("맥모닝", 500);
    
            for(int i = 0; i < carArray.length; i++) {
                carArray[i].driveMaxSpeed();
            }
    ```