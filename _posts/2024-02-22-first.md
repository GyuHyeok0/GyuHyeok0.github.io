---
layout: single
title: "Java "
categories: 
  - 자바 이론
toc: true
author_profiles: false
sidebar:
  nav: "docs"
tags:
  - Java
---

# 상속

- 부모클래스가 가지는 멤버를 자식클래스가 물려받아 자신의 멤버인 것처럼 사용할 수 있도록 만든 기술
- 멤버 외에 타입 또한 상속이 된다. (다형성의 토대)
- 자바는 단일 상속(하나의 클래스만을 부모클래스로 가짐)만 지원
- 클래스 간의 상속 시에는 extends 키워드를 사용

# Super

- **super**
부모클래스의 인스턴스 주소를 보관하는 레퍼런스 변수
자식클래스 내의 모든 생성자와 메소드 내에서 부모클래스의 레퍼런스 변수를 사용할 수 있음
Team Greedy
Copyright 2020. Team Greedy all rights reserved.
- **super()**
부모 생성자를 호출하는 구문으로 매개변수의 타입, 개수, 순서가 일치하는 부모의 생성자를 호출하게 됨
this()는 해당 클래스의 생성자를 호출하는 구문이다.
super()는 부모클래스가 가지는 private 생성자를 제외한 나머지 생성자를 호출하는 구문이다.

# 오버라이딩

- 오버라이딩(Overriding)이란?
부모클래스에서 상속받은 메소드를 자식클래스가 재정의하여 사용하는 것

# 다향성

- 하나의 인스턴스가 여러가지 타입을 가질 수 있는 것을 의미
- 다형성은 객체지향 프로그래밍의 3대 특징(캡슐화, 상속, 다형성) 중 하나이며, 객체지향 프로그래밍의
꽃이라고 볼 수 있음
- 다형성은 상속을 기반으로 한 기술

# 동적바인딩

- 컴파일 당시에는 해당 타입의 메소드와 연결되어 있다가 런타임 당시 실제 객체가 가진 오버라이딩 된
메소드로 바인딩이 바뀌어 동작하는 것을 의미
- **동적바인딩 성립 조건** ( 강제화 되어있을 겨우)
상속 관계로 이루어져 다형성이 적용된 경우, 메소드 오버라이딩이 되어 있어야 함

```jsx
Parent p = new child();
p.Methoda();
```

# Instanceof

- 현재 레퍼런스 변수가 어떤 클래스 타입의 객체 주소를 참조하고 있는지를 확인할 때 사용
클래스 타입이 맞으면 true, 맞지 않으면 false를 반환

```jsx
 동물 a1 = new 토끼

 if(a1 instanceof 토끼) {            //true
            ((토끼) a1).점프();             
        }
        if (a1 instanceof 호랑이) {      //false
            ((호랑이)a1).물어뜯기();
        }
```

# 클래스형변환

- 클래스 형변환은 업캐스팅과 다운캐스팅으로 구분할 수 있음
- **업캐스팅(up-casting)**
상위(부모) 타입으로 형변환
    
    ```jsx
    동물 a = (동물)new 토끼();
    ```
    
- **다운캐스팅(down-casting)**
하위(자식) 타입으로 형변환
    
    ```jsx
    ((토끼)a).메서드();   // 메서드 = 토끼의 메서드
    ```
    
- 묵시적 형변환
up-casting의 경우 묵시적 형변환이 적용 됨 (코드구현시 형변환 생략 가능)
    
    ```jsx
    동물 a = new 토끼();
    ```
    

## 다향성을 적용한 매개변수 활용

```jsx
public static void main(String[] args) {

        /* 수업목표. 다형성을 적용해서 매개변수로 활용 할 수 있다.
            목차. 1 하단에 멍기주기 메소드 만들기
            목차. 2 먹이주기 매소드 호출
         */
        Application03 app3 = new Application03();

        동물 a1 = new 토끼();
        동물 a2 = new 호랑이();

        app3.먹이주기(a1);
        app3.먹이주기(a2);

        app3.먹이주기(new 토끼());
        app3.먹이주기(new 호랑이());

    }
    /* 필기 다형성을 적용하지 않았다면, 호랑이에게 먹이를 주는 메소드와 토끼에게 먹이를 주는 메소드를
            두 개 다 만들어야 한다.
            즉 , 생산성이 좋아졌다고 보면 된다.

     */
    public void 먹이주기(동물 animal) {
        animal.먹기();
    }
```

# 추상클래스

- 추상메소드를 0개 이상 포함하는 클래스
- 추상클래스로는 인스턴스를 생성할 수 없음
- 추상클래스를 사용하려면 추상클래스를 상속받은 하위 클래스를 이용해서 인스턴스를 생성
(다형성을 활용)
- 사용 목적
추상클래스의 추상메소드는 오버라이딩에 대한 강제성이 부여 됨
(필수 기능을 정의하여 강제성을 부여해 개발 시 일관된 인터페이스를 제공)

# 추상메소드

- 메소드의 선언부만 있고 구현부가 없는 메소드
- 반드시 abstract 키워드를 메소드 헤드에 작성 하여야 함

# 인터페이스

- 추상메소드와 상수 필드만 가질 수 있는 클래스의 변형체
- 사용 목적
1. 추상클래스와 비슷하게 필요한 기능을 공통화 해서 강제성을 부여할 목적 (표준화)
2. 자바의 단일상속의 단점을 극복 (다중 상속)